#![allow(dead_code)]

/// --- SNAP START ---

/// Rolling Hash
///
/// Calculates the hash of a string (or sequence) using the Mersenne prime $2^{61} - 1$ as the modulus.
/// This allows for O(1) substring hash comparisons and O(1) concatenation checks.
///
/// # Complexity
/// - Initialization: O(N)
/// - Query: O(1)
///
/// # Examples
///
/// ## 1. Basic Usage (Substring Match)
/// ```
/// use atcoder_rust::template::rolling_hash::RollingHash;
///
/// let s: Vec<char> = "abracadabra".chars().collect();
/// let t: Vec<char> = "racada".chars().collect();
///
/// // Use a random base to avoid collisions (e.g., generated by `rand` crate or fixed for simple tests)
/// let base = 20231225; 
/// let rh_s = RollingHash::new(&s, base);
/// let rh_t = RollingHash::new(&t, base);
///
/// // Hash of s[2..8] ("racada")
/// let hash_sub = rh_s.query(2, 8);
/// // Hash of t[0..6] ("racada")
/// let hash_t_full = rh_t.query(0, 6);
///
/// assert_eq!(hash_sub, hash_t_full);
/// ```
///
/// ## 2. Finding Longest Common Prefix (LCP)
/// Using binary search with rolling hash to find the length of the LCP of two suffixes.
///
/// ```
/// use atcoder_rust::template::rolling_hash::RollingHash;
///
/// let s: Vec<char> = "banana".chars().collect();
/// let rh = RollingHash::new(&s, 10007);
///
/// // LCP of "banana" (index 0) and "nana" (index 2) is "0" -> length 0
/// // LCP of "nana" (index 2) and "na" (index 4) is "na" -> length 2
///
/// let lcp_len = rh.lcp(2, 4);
/// assert_eq!(lcp_len, 2);
/// ```
pub struct RollingHash {
    hash: Vec<u64>,
    power: Vec<u64>,
    modulus: u64,
}

impl RollingHash {
    // 2^61 - 1
    const MOD: u64 = (1 << 61) - 1;

    /// Creates a new RollingHash instance.
    ///
    /// # Arguments
    /// - `s`: Input sequence (e.g., `Vec<char>`, `Vec<u8>`, `Vec<i64>`).
    ///        Elements are internally cast to `u64`.
    /// - `base`: Base for the hash (should be a random number roughly between 2 and MOD-2).
    pub fn new<T>(s: &[T], base: u64) -> Self
    where
        T: Copy,
        u64: From<T>,
    {
        let n = s.len();
        let mut hash = vec![0; n + 1];
        let mut power = vec![0; n + 1];

        power[0] = 1;
        for i in 0..n {
            power[i + 1] = Self::mul(power[i], base);
            hash[i + 1] = Self::mul(hash[i], base) + u64::from(s[i]);
            if hash[i + 1] >= Self::MOD {
                hash[i + 1] -= Self::MOD;
            }
        }

        RollingHash {
            hash,
            power,
            modulus: Self::MOD,
        }
    }

    /// Returns the hash of the substring `[l, r)`.
    ///
    /// # Arguments
    /// - `l`: Start index (inclusive).
    /// - `r`: End index (exclusive).
    pub fn query(&self, l: usize, r: usize) -> u64 {
        assert!(l <= r && r < self.hash.len());
        let res = self.hash[r] + Self::MOD - Self::mul(self.hash[l], self.power[r - l]);
        if res >= Self::MOD {
            res - Self::MOD
        } else {
            res
        }
    }

    /// Returns the hash of the entire string.
    pub fn get_all(&self) -> u64 {
        self.hash[self.hash.len() - 1]
    }

    /// Calculates `(a * b) % (2^61 - 1)` without overflow using `u128`.
    #[inline]
    fn mul(a: u64, b: u64) -> u64 {
        let t = a as u128 * b as u128;
        let mut res = (t >> 61) as u64 + (t as u64 & Self::MOD);
        if res >= Self::MOD {
            res -= Self::MOD;
        }
        res
    }

    /// Calculates the length of the Longest Common Prefix (LCP) of two suffixes starting at `i` and `j`.
    ///
    /// # Arguments
    /// - `i`: Start index of the first suffix.
    /// - `j`: Start index of the second suffix.
    pub fn lcp(&self, i: usize, j: usize) -> usize {
        let n = self.hash.len() - 1;
        let len = std::cmp::min(n - i, n - j);
        let mut low = 0;
        let mut high = len + 1;

        while high - low > 1 {
            let mid = (low + high) / 2;
            if self.query(i, i + mid) == self.query(j, j + mid) {
                low = mid;
            } else {
                high = mid;
            }
        }
        low
    }
}